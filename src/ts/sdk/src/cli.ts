
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache, ActualStringClass, sendPayloadTx, getSimulationKeys } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Econia from './econia';

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  console.log(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

const program = new Command();

program
  .name('yarn cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const assets_init_coin_types = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Assets.buildPayload_init_coin_types();
  await sendPayloadTx(client, account, payload);
}

program
  .command("assets:init-coin-types")
  .description("")

  .action(assets_init_coin_types);


const market_cancel_all_limit_orders_user = async (host: string, market_id: string, side: string) => {
  const {client, account} = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const payload = Econia.Market.buildPayload_cancel_all_limit_orders_user(host_, market_id_, side_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:cancel-all-limit-orders-user")
  .description("")
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .action(market_cancel_all_limit_orders_user);


const market_cancel_limit_order_user = async (host: string, market_id: string, side: string, order_id: string) => {
  const {client, account} = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const order_id_ = u128(order_id);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(host_, market_id_, side_, order_id_);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .argument('<order_id>')
  .action(market_cancel_limit_order_user);


const market_place_limit_order_user = async (BaseType: string, QuoteType: string, host: string, market_id: string, side: string, size: string, price: string, post_or_abort: string, fill_or_abort: string, immediate_or_cancel: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side=='true';
  const size_ = u64(size);
  const price_ = u64(price);
  const post_or_abort_ = post_or_abort=='true';
  const fill_or_abort_ = fill_or_abort=='true';
  const immediate_or_cancel_ = immediate_or_cancel=='true';
  const payload = Econia.Market.buildPayload_place_limit_order_user(host_, market_id_, side_, size_, price_, post_or_abort_, fill_or_abort_, immediate_or_cancel_, [BaseType_, QuoteType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:place-limit-order-user")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<side>')
  .argument('<size>')
  .argument('<price>')
  .argument('<post_or_abort>')
  .argument('<fill_or_abort>')
  .argument('<immediate_or_cancel>')
  .action(market_place_limit_order_user);


const market_place_market_order_user = async (BaseType: string, QuoteType: string, host: string, market_id: string, direction: string, min_base: string, max_base: string, min_quote: string, max_quote: string, limit_price: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction=='true';
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const payload = Econia.Market.buildPayload_place_market_order_user(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseType_, QuoteType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:place-market-order-user")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<direction>')
  .argument('<min_base>')
  .argument('<max_base>')
  .argument('<min_quote>')
  .argument('<max_quote>')
  .argument('<limit_price>')
  .action(market_place_market_order_user);


const market_register_market_pure_coin = async (BaseCoinType: string, QuoteCoinType: string, lot_size: string, tick_size: string) => {
  const {client, account} = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const lot_size_ = u64(lot_size);
  const tick_size_ = u64(tick_size);
  const payload = Econia.Market.buildPayload_register_market_pure_coin(lot_size_, tick_size_, [BaseCoinType_, QuoteCoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:register-market-pure-coin")
  .description("")
  .argument('<TYPE_BaseCoinType>')
  .argument('<TYPE_QuoteCoinType>')
  .argument('<lot_size>')
  .argument('<tick_size>')
  .action(market_register_market_pure_coin);


const market_swap_between_coinstores = async (BaseCoinType: string, QuoteCoinType: string, host: string, market_id: string, direction: string, min_base: string, max_base: string, min_quote: string, max_quote: string, limit_price: string) => {
  const {client, account} = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction=='true';
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const payload = Econia.Market.buildPayload_swap_between_coinstores(host_, market_id_, direction_, min_base_, max_base_, min_quote_, max_quote_, limit_price_, [BaseCoinType_, QuoteCoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("market:swap-between-coinstores")
  .description("")
  .argument('<TYPE_BaseCoinType>')
  .argument('<TYPE_QuoteCoinType>')
  .argument('<host>')
  .argument('<market_id>')
  .argument('<direction>')
  .argument('<min_base>')
  .argument('<max_base>')
  .argument('<min_quote>')
  .argument('<max_quote>')
  .argument('<limit_price>')
  .action(market_swap_between_coinstores);


const registry_init_registry = async () => {
  const {client, account} = readConfig(program);

  const payload = Econia.Registry.buildPayload_init_registry();
  await sendPayloadTx(client, account, payload);
}

program
  .command("registry:init-registry")
  .description("")

  .action(registry_init_registry);


const user_deposit_from_coinstore = async (CoinType: string, market_id: string, general_custodian_id: string, amount: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_deposit_from_coinstore(market_id_, general_custodian_id_, amount_, [CoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:deposit-from-coinstore")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<market_id>')
  .argument('<general_custodian_id>')
  .argument('<amount>')
  .action(user_deposit_from_coinstore);


const user_register_market_account = async (BaseType: string, QuoteType: string, market_id: string, general_custodian_id: string) => {
  const {client, account} = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const payload = Econia.User.buildPayload_register_market_account(market_id_, general_custodian_id_, [BaseType_, QuoteType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:register-market-account")
  .description("")
  .argument('<TYPE_BaseType>')
  .argument('<TYPE_QuoteType>')
  .argument('<market_id>')
  .argument('<general_custodian_id>')
  .action(user_register_market_account);


const user_withdraw_to_coinstore = async (CoinType: string, market_id: string, amount: string) => {
  const {client, account} = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const amount_ = u64(amount);
  const payload = Econia.User.buildPayload_withdraw_to_coinstore(market_id_, amount_, [CoinType_]);
  await sendPayloadTx(client, account, payload);
}

program
  .command("user:withdraw-to-coinstore")
  .description("")
  .argument('<TYPE_CoinType>')
  .argument('<market_id>')
  .argument('<amount>')
  .action(user_withdraw_to_coinstore);




program.parse();
